import { prepEditor, wipeEditor } from './editor.js';
import Vector from './Vector.js';

const BLUE = 1, RED = 2;

const gameTypeNames = [
    '',
    'Free For All',
    'Capture The Flag',
    'Battle Royale',
    'Development',
    'Conquest',
    'Editor',
];

const gameTypeDescriptions = [
    '',
    'Everyone versus everyone deathmatch. No teams.',
    'Players split into 2 teams. 2 flags are placed inside each base. The objective is to move the enemy flag from their base to your base.',
    'Players spawn at random locations all across the map. Destroyed players will not respawn. Last player standing wins.',
    'Game environments for development and testing.'
];

let currentServer = null; //used only for UI purposes
let ctf = {};
let conquest = {};
const blue_color = 0x4076E2, red_color = 0xEA4242;

let firewallSprites = {};
let minimapFirewallMask = null;
let minimapFirewallVisible = false;
let firewall = {
    radius: 0,
    pos: Vector.zero(),
    speed: 0
};

let unlockedFeature = {};

const loginOrigin = 'https://login.airmash.online';
let loginIdentityProvider = 0;
let loginNonce = null;

Games.setup = function() {
    $('#open-menu').on('click', function(event) {
        Games.openServerMenu();
        event.stopPropagation();
    });
    $('#playserver').on('click', function(event) {
        Games.openServerMenu(true);
        event.stopPropagation();
    });
    $('#skinbutton').on('click', function(event) {
        UI.openSkinMenu();
        event.stopPropagation();
    });
    $('#loginbutton').on('click', function(event) {
        UI.openLogin(),
        event.stopPropagation()
    });
    $('#login-microsoft').on('click', function() {
        Games.popupLogin(1)
    });
    $('#login-google').on('click', function() {
        Games.popupLogin(2)
    });
    $('#login-twitter').on('click', function() {
        Games.popupLogin(3)
    });
    $('#login-reddit').on('click', function() {
        Games.popupLogin(4)
    });
    $('#login-twitch').on('click', function() {
        Games.popupLogin(5)
    });
    $('#loginselector').on('click', function(e) {
        e.stopPropagation()
    });
    $('#gotomainpage').on('click', Games.redirRoot);
    $('#lifetime-signin').on('click', Games.redirRoot);
    
    // Loading user authentication data from local storage, if it exists
    if (Tools.loadAuth()) {
        Games.playerAuth();
    }
    else { 
        Games.playerGuest();
    }

    // Poll settings every second to see if any change needs to be sent to backend service
    setInterval(Tools.syncRemoteSettings, 1000);

    Games.selectServer(null, {
        "url": "wss://ffa.airmash.xyz/ffa",
        "region_name": "US",
        "name": "Free For All #1",
        "nameShort": "FFA #1",
    }, true);

    refreshGamesData(true).then((servers) => {
        updatePlayersOnline(servers);
    });
};

var receiveLoginMessage = function(msg) {
    if (msg.origin !== loginOrigin) {
        console.log('bad origin for login message: ' + msg.origin);
        return;
    }

    if (msg.data.provider !== loginIdentityProvider) {
        console.log('identity provider does not match: ' + msg.data.provider);
        return;
    }
    loginIdentityProvider = 0;
    
    if (msg.data.nonce !== loginNonce) {
        console.log('nonce does not match: ' + msg.data.nonce);
        return;
    }
    loginNonce = null;

    window.loginSuccess({
        tokens: msg.data.tokens,
        identityprovider: msg.data.provider,
        loginname: msg.data.loginname
    });
}

/*
 * The popup window opened on login.airmash.online ends up posting a message
 * back to the main window like so:
 * 
 *   <html>
 *     <head>
 *       <script type="text/javascript">
 *         function closePopup(){ 
 *           window.opener.postMessage({
 *               nonce:       "…",  // randomly generated by client, for CSRF prevention
 *               tokens:      "…",  // tokens used by client to authenticate with settings service and game servers
 *               provider:     …,   // number indicating which identity provider  }- these are for client 
 *               loginname:   "…",  // account name or email                      }  display only
 *              }, "https://…"); // expected to match origin of window.opener e.g. https://airmash.online
 *           window.close();
 *         }
 *       </script>
 *     </head>
 *     <body onload="closePopup()"></body>
 *   </html>
 * 
 * On the original airma.sh, the login window could call window.opener.loginSuccess()
 * directly as they had the same origin. But now we will want to use the same login
 * flow from multiple domains (airmash.online, starma.sh, test.airmash.online, ...),
 * therefore use Window.postMessage() and Window.addEventListener() for cross-origin 
 * communication
 * 
 */
Games.popupLogin = function(identityProvider) {
    window.addEventListener('message', receiveLoginMessage, { once : true });

    loginIdentityProvider = identityProvider;
    loginNonce = Tools.randomID(32);
    let url = `${loginOrigin}/login?provider=${loginIdentityProvider}&nonce=${loginNonce}&origin=${window.origin}`;

    openLoginWindow(url, 'Login', identityProvider == 4 ? 900 : 500, identityProvider == 5 ? 800 : 600);
};

var openLoginWindow = function(url, title, width, height) {
    // Calculate window position for centre
    let x = window.screenLeft ? window.screenLeft : window.screenX;
    let y = window.screenTop ? window.screenTop : window.screenY;
    let left = (window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : screen.width) / 2 - width / 2 + x;
    let top = (window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : screen.height) / 2 - height / 2 + y;

    // Open login window at this position
    window.open(url, title, `width=${width}, height=${height}, top=${top}, left=${left}`);
};

window.loginSuccess = function(loginsettings) {
    Tools.setAuth(loginsettings);
    Games.playerAuth();
    UI.closeLogin();
};

window.loginFailure = function() {};

Games.playerGuest = function() {
    UI.show('#playbutton', true);
    UI.show('#loginbutton', true);
};

Games.playerAuth = function() {
    Tools.ajaxGet(
        `https://${game.backendHost}/settings`,
        config.auth.tokens.settings,
        function(remoteSettings) {
            if (remoteSettings != null) {
                game.loggedIn = true;

                let identityProvider = ['', 'Microsoft', 'Google', 'Twitter', 'Reddit', 'Twitch'][config.auth.identityprovider || 0];
                let htmlName = UI.escapeHTML((config.auth.loginname || '').substr(0, 30));
                htmlName += `<span class="grey">(${identityProvider})</span>`;

                let htmlLogout = htmlName + '<span class="link" onclick="Games.logout()">Logout</span>';
                let htmlMenuLogout = 'Logged in as ' + htmlName + '<span class="button" onclick="Games.logout()">LOG OUT</span>';
                $('#logout').html(htmlLogout);
                $('#logout-mainmenu').html(htmlMenuLogout);

                $('#loginbutton').remove();
                $('#lifetime-account').remove();

                $('#playbutton').html('PLAY');
                UI.show('#playbutton', true);
                
                Tools.setSettings(remoteSettings);
                Tools.applySettingsToGame();
            } else {
                Games.playerGuest();
            }
        });
};

Games.logout = function() {
    Tools.setAuth({});
    Tools.removeSetting('flag');
    Tools.removeSetting('name');
    window.location = window.location;
};

async function refreshGamesData(fromMainPage) {
    const url = `https://server-manager.airmash.workers.dev/servers?${Date.now()}`;
    const legacy_url = `https://${game.backendHost}/games${'?'+Date.now()}${fromMainPage?'&main=1':''}`;

    // fetch servers
    const servers = await fetch(url).then(res=>res.json());
    servers.forEach(x=>x.type=gameTypeNames[x.type]);

    // fetch legacy servers
    {
        const response = await fetch(legacy_url).then(response => response.json());
        const gamesData = JSON.parse(response.data);

        // Set flag from country code in response
        if (game.myFlag == 'xx') {
            game.myFlag = response.country;
        }

        // On protocol mismatch, reload the page
        // if (fromMainPage && game.protocol != response.protocol) {
        //     if (window.location.hash !== '#reload') {
        //         Tools.ajaxPost(`https://${game.backendHost}/clienterror`, { type: 'protocol' }, function() {
        //             UI.showMessage('alert', '<span class="mainerror">Protocol update<br>Your client is being updated to the new version</span>', 30000);
        //             setTimeout(function() { window.location = '/?' + Tools.randomID(10) + '#reload' }, 5000);
        //         });
        //     }
        //     else {
        //         Tools.ajaxPost(`https://${game.backendHost}/clienterror`, { type: 'protocolretry' });
        //     }
        // }

        for (const {id:region_id, name:region_name, games} of gamesData) {
            for (const {id, type, name, nameShort, host, path, players, bots} of games) {
                servers.push({
                    url: `wss://${host}/${path}`,
                    region_name,
                    id,
                    name,
                    nameShort,
                    type: gameTypeNames[type],
                    players:players||0,
                    bots:bots||0
                });

                //ping
                // const idx = servers.length;
                // navigator.locks.request("ping", async (lock) => {
                //     const pingStartTimestamp = performance.now();
                //     await fetch(`https://${host}/ping?${pingStartTimestamp}`, {mode:'no-cors'});
                //     const ping = performance.now() - pingStartTimestamp;
                //     (document.querySelector(`#servermenu .item:nth-child(${idx}) .ping`)||{}).textContent = ping;
                // });
            }
        }
    }

    if (window.DEVELOPMENT) {
        servers.push({
            url: `ws://127.0.0.1:3501?ffa`,
            region_name: 'dev',
            name: 'dev',
            nameShort: 'dev',
            type: gameTypeNames[1],
            players:0,
            bots:0
        });
    }

    console.log('servers', servers);
    return servers;
};

function updatePlayersOnline(servers) {
    const playerCount = servers.reduce((acc,{players,bots})=>acc+players-(bots||0), 0);
    let html = '<div class="item smallerpad">' + playerCount + '</div>player' + (playerCount > 1 ? 's' : '') + ' online';
    document.querySelector('#gameinfo').innerHTML = html;
};

// info tooltip
//                      html += '<span class="infocontainer">&nbsp;<div class="infoicon">' + getGameTypeDescriptionHtml(type) + '</div></span>';
var getGameTypeDescriptionHtml = function(gameType) {
    return `<div class="infott">${gameTypeDescriptions[gameType]}<div class="arrow"></div></div>`;
};

// update login menu
function updateServer({name, nameShort, region_name} = {}) {
    let html = '';
    html += '<div class="playtop" style="left:12px">SERVER</div>';
    if (nameShort)
        html += `<div class="playbottom" style="left:12px">${UI.escapeHTML(name)}&nbsp;&nbsp;<span style="color: #c8c8c8">•&nbsp;&nbsp;${UI.escapeHTML(region_name)}</span></div>`;
    document.querySelector('#playserver').innerHTML = html;
}

Games.openServerMenu = async function(fromMainPage) {
    UI.showPanel("#servermenu");

    const servers = await refreshGamesData(true);

    let html = '';
    if (servers.length > 0) {
        html += `<div class="item header">
            <div class="">NAME</div>
            <div class="">REGION</div>
            <div class="">TYPE</div>
            <div class="">PLAYERS</div>
            <!--<div class="">PING</div>-->
            </div>`;       
        for (const {name, type, nameShort, region_name, players, bots, url} of servers) {
            html += `<div class="item selectable" onclick="Games.selectServer(event, {url:'${UI.escapeString(url)}', nameShort:'${UI.escapeString(nameShort)}', name:'${UI.escapeString(name)}', region_name:'${UI.escapeString(region_name)}'}, ${fromMainPage?'true':'false'})">
                <div class="">${UI.escapeHTML(name)}</div>
                <div class="">${UI.escapeHTML(region_name)}</div>
                <div class="">${UI.escapeHTML(type)}</div>
                <div class="">${UI.escapeHTML(players)}</div>
                <!--<div class="ping"></div>-->
            </div>`;
        }
    } else {
    }

    document.querySelector("#servermenu .header").textContent = fromMainPage ? 'Choose server' : 'Switch server';
    document.querySelector("#servermenu .servers").innerHTML = html;
};

Games.closeServerMenu = function() {
    UI.hidePanel('#servermenu');
};

Games.selectServer = function(e, server, fromMainPage) {
    e?.stopPropagation();
    if (e)
        Sound.UIClick();
    if (fromMainPage)
        updateServer(server);
    Games.closeServerMenu();
    game.serverUrl = server.url;
    Games.setCurrentServer(server);
    if (!fromMainPage)
        Games.switchGame();
};

Games.setCurrentServer = function(server) {
    currentServer = server;
};

Games.getCurrentServer = function() {
    return currentServer;
};

Games.redirRoot = function() {
    game.reloading = true;
    window.location = '/';
};

Games.switchGame = function() {
    game.myScore = 0;
    game.server = {};
    game.state = Network.STATE.CONNECTING;
    Network.shutdown();
    Particles.wipe();
    Players.wipe();
    Mobs.wipe();
    UI.reconnection();
    Games.start(game.myOriginalName);
};

Games.highlightInput = function(id) {
    $(id).css({
        transition: 'none',
        transform: 'scale(1.1)',
        'background-color': 'rgb(90, 30, 30)'
    });
    $(id).width();
    $(id).css({
        transition: 'all 0.5s ease-in-out',
        transform: 'scale(1)',
        'background-color': 'rgb(30, 30, 30)'
    });
    setTimeout(function() { $(id).focus() }, 200);
};

Games.start = function(playerName, fromMainPage) {
    if (fromMainPage && game.state == Network.STATE.CONNECTING) {
        return;
    }

    // Clear the main page if we're on it
    if (game.state == Network.STATE.LOGIN) {
        Tools.wipeReel();
    }
    game.state = Network.STATE.CONNECTING;

    // Any change to player name gets saved to settings upon game start
    let settings = {
        name: playerName
    };

    // Persist settings to storage
    Tools.setSettings(settings);

    UI.gameStart(playerName, fromMainPage);
};

/**
 * Prepare new game upon receipt of LOGIN message
 */
Games.prep = function() {
    // Remove anything that may persist from previous game type
    Games.wipe();

    UI.show("#roomnamecontainer");
    UI.show("#scoreboard"); 
    UI.show("#scorebig");
    UI.show("#settings");

    switch(game.gameType) {
        case GameType.CTF:
            // Display CTF status (team flags and their carriers) in game-specific region
            $('#gamespecific').html(
                '<div class="blueflag"></div>' +
                '<div id="blueflag-name" class="blueflag-player">&nbsp;</div>' + 
                '<div class="redflag"></div>' + 
                '<div id="redflag-name" class="redflag-player">&nbsp;</div>'
                );
            UI.show('#gamespecific');
            break;
        
        case GameType.BTR:
            // Clear game-specific region
            $('#gamespecific').html('');
            UI.show('#gamespecific');
            break;

        case GameType.FFA:
            $('#gamespecific').html('');
            if (game.server.config.tdmMode) {
                $('#gamespecific').html(
                    '<div id="blueflag-name" class="blueflag-player" style="color: #4076E2">0</div>' + 
                    '<div id="redflag-name" class="redflag-player" style="color: #EA4242">0</div>'
                    );
                UI.show('#gamespecific');
            }
            break;

        case GameType.CONQUEST:
            this.reducedFactor = false;

            conquest = { 
                zones: [],
                score_blue: 0, 
                score_red: 0, 
                blue_bar: null, 
                red_bar: null, 
            };

            const bar_width = 200, bar_height = 8;
            conquest.red_bar = createProgressbar(red_color, 1, bar_width, bar_height);
            conquest.blue_bar = createProgressbar(blue_color, -1, bar_width, bar_height);
            updateProgressbar(conquest.red_bar, 0);
            updateProgressbar(conquest.blue_bar, 0);
            break;

        case GameType.EDITOR:
            prepEditor();
            break;
    }    
};
    
function createControlpoint(name, [x, y], [x1, y1], width, debug) {
    const w = debug ? 600 : width;
    const halfwidth = w/2;

    let doodad_field = Textures.init("doodadField", { position: [x, y], scale: 0.5});

    const texture = PIXI.RenderTexture.create(w, w);

    const line = new PIXI.Graphics();
    //line.pivot.set(halfwidth, halfwidth);
    if (debug)
        line.position.set(halfwidth-width/2, halfwidth-width/2);

    const label = new PIXI.Text(name, new PIXI.TextStyle({fill:0xffffff}));
    label.anchor.set(0.5, 0.5);
    label.position.set(halfwidth, halfwidth);

    const circle = new PIXI.Graphics();
    circle.lineStyle(2, 0xFFFFFF, 1);
    circle.beginFill(0xffffff, 0);
    circle.drawCircle(halfwidth, halfwidth, halfwidth);
    circle.endFill();

    const obj = new PIXI.Container();
    obj.addChild(line);
    obj.addChild(label);
    if (debug)
        obj.addChild(circle);

    const big = new PIXI.Sprite(texture);
    big.anchor.set(0.5, 0.5);
    big.x = x;
    big.y = y;
    game.graphics.layers.fields.addChild(big);

    const ui = new PIXI.Container();
    const ui_bg = new PIXI.Sprite(PIXI.Texture.WHITE);
    ui_bg.width = w;
    ui_bg.height = w;
    ui_bg.tint = 0x000000;
    ui_bg.alpha = 0.2;
    ui.addChild(ui_bg);
    const _ui = new PIXI.Sprite(texture);
    //ui.x = x1;
    ui.y = y1;
    ui.scale.set(0.4);
    ui.addChild(_ui);
    game.graphics.layers.ui0.addChild(ui);
    
    const minimap = new PIXI.Sprite(texture);
    minimap.anchor.set(0.5, 0.5);
    minimap.scale.set(0.3);
    game.graphics.layers.ui2.addChild(minimap);
    Graphics.minimapMob(minimap, x, y);   
    
    return {texture, obj, big, line, label, circle, ui, width, minimap, doodad_field, mapId:game.server.config.mapId};
}

function createProgressbar(color, direction, width, height) {
    const mask = new PIXI.Sprite(PIXI.Texture.WHITE);
    mask.width = width;
    mask.height = height;

    const container = new PIXI.Container();
    game.graphics.layers.ui0.addChild(container);
    container.pivot.set(width/2, height/2);
    //container.x = Math.round(game.halfScreenX + direction*x_offset);
    container.y = 50;
    container.mask = mask;
    container.addChild(mask);

    const shadow = new PIXI.Sprite(PIXI.Texture.WHITE);
    shadow.tint = 0x000000;
    shadow.alpha = 0.2;
    shadow.width = width;
    shadow.height = height;
    container.addChild(shadow);

    const p = new PIXI.Sprite(PIXI.Texture.WHITE);
    p.tint = color;
    p.width = width;
    p.height = height;
    container.addChild(p);

    return {container, p, direction, width};
}

function updateProgressbar({p, direction, width}, perc) {
    if (direction > 0)
        p.position.set(width - (perc*width), 0);
    else
        p.position.set(-width + (perc*width), 0);
}

Games.wipe = function() {
    // Clear BTR firewall
    removeFirewall();

    // If exists, clear all CTF graphics
    removeCtfObjects();

    // clear conquest graphics
    removeConquestObjects();

    // editor
    wipeEditor();
};

function removeCtfObjects() {
    if (ctf.flagRed) {
        game.graphics.layers.flags.removeChild(ctf.flagRed.sprite);
        game.graphics.layers.shadows.removeChild(ctf.flagRed.spriteShadow);
        game.graphics.layers.ui3.removeChild(ctf.flagRed.minimapSprite);
        game.graphics.layers.ui2.removeChild(ctf.flagRed.minimapBase);
        ctf.flagRed.sprite.destroy();
        ctf.flagRed.spriteShadow.destroy();
        ctf.flagRed.minimapSprite.destroy();
        ctf.flagRed.minimapBase.destroy();
        ctf.flagRed = null;
    }
    if (ctf.flagBlue) {
        game.graphics.layers.flags.removeChild(ctf.flagBlue.sprite);
        game.graphics.layers.shadows.removeChild(ctf.flagBlue.spriteShadow);
        game.graphics.layers.ui3.removeChild(ctf.flagBlue.minimapSprite);
        game.graphics.layers.ui2.removeChild(ctf.flagBlue.minimapBase);
        ctf.flagBlue.sprite.destroy();
        ctf.flagBlue.spriteShadow.destroy();
        ctf.flagBlue.minimapSprite.destroy();
        ctf.flagBlue.minimapBase.destroy();
        ctf.flagBlue = null;
    }
}

function removeConquestObjects(isMapChange) {
    if (conquest.zones) {
        for (let cp of conquest.zones) {
            game.graphics.layers.fields.removeChild(cp.big);
            cp.big.destroy();
            game.graphics.layers.ui0.removeChild(cp.ui);
            cp.ui.destroy();
            game.graphics.layers.ui2.removeChild(cp.minimap);
            cp.minimap.destroy();

            game.graphics.layers.fields.removeChild(cp.doodad_field);
            cp.doodad_field.destroy();

        }
        conquest.zones = [];

        if (!isMapChange) {
            game.graphics.layers.ui0.removeChild(conquest.red_bar.container);
            conquest.red_bar.container.destroy();
            game.graphics.layers.ui0.removeChild(conquest.blue_bar.container);
            conquest.blue_bar.container.destroy();
        }
    }
}

function readIntegers(floatValue) {
    const floatArray = new Float32Array(1);
    floatArray[0] = floatValue;
    const intArray = new Int32Array(floatArray.buffer);
    const packedInt = intArray[0];
    const unsignedInt2 = packedInt & 0b11;
    const unsignedInt14a = (packedInt >> 2) & 0x3FFF;
    const unsignedInt14b = (packedInt >> 16) & 0x3FFF;
    const int2 = unsignedInt2 - 2;
    const int14a = unsignedInt14a - 8192;
    const int14b = unsignedInt14b - 8192;
    return [int2, int14a, int14b];
}

Games.networkControlpoint = function(msg) {
    console.log('networkControlpoint', msg);
    // reset if map has changed
    if (conquest.zones[0] && conquest.zones[0].mapId != game.server.config.mapId) {
        //if (msg.type !== 97) throw "assert";
        removeConquestObjects(true);
    }

    // create controlpoints lazily
    if (!conquest.zones[msg.id]) {
        // if (msg.type !== 97 && msg.type !== 98) throw "assert";
        // if (conquest.zones.length !== msg.id) throw "assert";
        const width = 56;
        const i = msg.id;
        conquest.zones[i] = createControlpoint("ABCDEFGH"[i], [msg.posX, msg.posY], [0, 40],  width);

        Games.update(true);
    }

    this.reducedFactor = Tools.reducedFactor();

    let zone = conquest.zones[msg.id];
    // 97, 98, 99: horrible hack to avoid changing protocol, see also server controlpoints.ts
    if (msg.type === 97 || msg.type === 98) {
        [zone.team, zone.progress, zone.netplayers] = [0, 0, 0];
        if (msg.type === 98) {
            conquest.score_blue = 0;
            conquest.score_red = 0;            
        }
    } else if (msg.type === 99) {
        [, conquest.score_blue, conquest.score_red] = readIntegers(msg.posX);
        conquest.score_blue *= 60;
        conquest.score_red *= 60;

        [zone.team, zone.progress, zone.netplayers] = readIntegers(msg.posY);
        zone.team = -zone.team;
    }
    
};

/**
 * GAME_FLAG message handler
 */
Games.networkFlag = function(msg) {

    // reset ctf bases if map has changed
    if (ctf.flagRed && ctf.flagRed.mapId != game.server.config.mapId) {
        removeCtfObjects();
    }

    if (msg.flag == RED && !ctf.flagRed) {
        ctf.flagRed = {
            mapId: game.server.config.mapId,
            visible: false,
            playerId: null,
            direction: 1,
            diffX: 0,
            momentum: 0,
            position: Vector.zero(),
            basePos: new Vector(msg.posX+2, msg.posY-4), //exploit the fact that (at start and when map changed) base pos = flag pos (config.objects.bases is not yet loaded)
            sprite: Textures.init('ctfFlagRed', {
                scale: 0.4,
                visible: false
            }),
            spriteShadow: Textures.init('ctfFlagShadow', {
                scale: 0.4 * 1.1,
                visible: false
            }),
            minimapSprite: Textures.init('minimapFlagRed'),
            minimapBase: Textures.init('minimapBaseRed')
        };
        if (game.gameType == GameType.FFA || game.gameType == GameType.EDITOR)
            ctf.flagRed.minimapBase.visible = false;
        if (game.gameType == GameType.CTF)
            Graphics.minimapMob(ctf.flagRed.minimapBase, ctf.flagRed.basePos.x, ctf.flagRed.basePos.y);
    }
    if (msg.flag == BLUE && !ctf.flagBlue) {
        ctf.flagBlue = {
            mapId: game.server.config.mapId,
            visible: false,
            playerId: null,
            direction: 1,
            diffX: 0,
            momentum: 0,
            position: Vector.zero(),
            basePos: new Vector(msg.posX+1, msg.posY-1),
            sprite: Textures.init('ctfFlagBlue', {
                scale: 0.4,
                visible: false
            }),
            spriteShadow: Textures.init('ctfFlagShadow', {
                scale: 0.4 * 1.1,
                visible: false
            }),
            minimapSprite: Textures.init('minimapFlagBlue'),
            minimapBase: Textures.init('minimapBaseBlue')
        };
        if (game.gameType == GameType.FFA || game.gameType == GameType.EDITOR)
            ctf.flagBlue.minimapBase.visible = false;
        if (game.gameType == GameType.CTF)
            Graphics.minimapMob(ctf.flagBlue.minimapBase, ctf.flagBlue.basePos.x, ctf.flagBlue.basePos.y);
    }

    // Check if this is a blue (1) or red (2) team flag
    let flag, selector, flagCaptures;
    if (msg.flag == BLUE) {
        flag = ctf.flagBlue;
        selector = '#blueflag-name';
        flagCaptures = msg.blueteam;
    }
    else {
        flag = ctf.flagRed;
        selector = '#redflag-name';
        flagCaptures = msg.redteam;
    }

    // Common values for flag display
    flag.momentum = 0;
    flag.direction = 1;
    flag.sprite.scale.x = 0.4;
    flag.sprite.rotation = 0;
    flag.spriteShadow.scale.x = 0.4 * 1.1;
    flag.spriteShadow.rotation = 0;

    // Team score (successful flag captures)
    let html = `<span class="rounds">${flagCaptures}<span class="divider">/</span>3</span>`;

    if (msg.type == 1) {
        // Flag is not being carried
        flag.playerId = null;
        flag.position.x = msg.posX;
        flag.position.y = msg.posY;
        flag.sprite.position.set(msg.posX, msg.posY);
        let shadow = Graphics.shadowCoords(new Vector(msg.posX,msg.posY));
        flag.spriteShadow.position.set(shadow.x, shadow.y),
        Graphics.minimapMob(flag.minimapSprite, msg.posX, msg.posY);
        $(selector).html(html);
    } else {
        // Flag is being carried
        flag.playerId = msg.id;
        let player = Players.get(msg.id);
        if (player != null) {
            // Position of player name is to the left for blue, right for red
            if (msg.flag == 1) {
                html = UI.escapeHTML(player.name) + html;
            }
            else {
                html += UI.escapeHTML(player.name);
            }
        }
        flag.diffX = player.pos.x;
        $(selector).html(html);
    }

    updateCtfFlag(flag, false);

    game.flagEnabled = true;
};

var updateCtfFlag = function(flag, isResize) {
    // If window is being resized, redraw minimap
    if(isResize && game.flagEnabled) {
        Graphics.minimapMob(flag.minimapSprite, flag.position.x, flag.position.y);
        if (game.gameType == GameType.CTF)
            Graphics.minimapMob(flag.minimapBase, flag.basePos.x, flag.basePos.y);
    }

    if(flag.playerId != null) {
        // Flag is being carried
        let carrier = Players.get(flag.playerId);
        if (carrier != null) {
            // Flag visibility must match visibility of flag carrier player (i.e. are they on-screen?)
            if(carrier.render != flag.visible) {
                flag.visible = carrier.render;
                flag.sprite.visible = carrier.render;
                flag.spriteShadow.visible = carrier.render;

                if(carrier.render) {
                    flag.momentum = 0;
                    flag.direction = 1;
                    flag.diffX = carrier.pos.x;
                }
            }

            // Accuracy of flag minimap position depends on whether flag carrier player is visible
            if(carrier.render) {
                Graphics.minimapMob(flag.minimapSprite, carrier.pos.x, carrier.pos.y);
            } else {
                Graphics.minimapMob(flag.minimapSprite, carrier.lowResPos.x, carrier.lowResPos.y);
            }
        }

        // Display flag if flag carrier player is visible
        if(flag.visible) {
            flag.position.x = carrier.pos.x;
            flag.position.y = carrier.pos.y;
            flag.sprite.position.set(carrier.pos.x, carrier.pos.y);

            let shadow = Graphics.shadowCoords(carrier.pos);
            flag.spriteShadow.position.set(shadow.x, shadow.y),

            flag.momentum = Tools.clamp(flag.momentum + (carrier.pos.x - flag.diffX) * game.timeFactor, -40, 40);
            let directionModifier = flag.momentum > 0 ? 0.1 : -0.1;
            flag.direction = Tools.clamp(flag.direction - directionModifier * game.timeFactor, -0.4, 0.4);
            flag.sprite.scale.x = flag.direction;
            flag.spriteShadow.scale.x = 1.1 * flag.direction;

            let rotation = 0.04 * -(carrier.pos.x - flag.diffX) * game.timeFactor;
            flag.sprite.rotation = rotation;
            flag.spriteShadow.rotation = rotation;

            flag.diffX = carrier.pos.x;
        }
    } else {
        // Flag is not being carried, display if on-screen
        let isVisible = Graphics.inScreen(flag.position, 128);
        if(isVisible != flag.visible) {
            flag.visible = isVisible;
            flag.sprite.visible = isVisible;
            flag.spriteShadow.visible = isVisible;
        }
    }
};

/**
 * GAME_SPECTATE message handler
 */
Games.spectate = function(playerId) {
    // If entering spectator mode and we're not playing BTR, display message
    if (game.spectatingID == null && game.gameType !== GameType.BTR) {
        UI.showMessage('alert', '<span class="info">SPECTATOR MODE</span>Click on Respawn to resume playing', 4000);
    }
    game.spectatingID = playerId;

    // Display spectator status text
    let html = '';
    let player = Players.get(playerId);
    html += '<div id="spectator-tag" class="spectating">Spectating ' + (player == null ? '' : UI.escapeHTML(player.name)) + '</div>';
    html += '<div class="buttons">'
    html += '<div onclick="Network.spectateNext()" class="changeplayer left"><div class="arrow"></div></div>';
    html += '<div onclick="Network.spectatePrev()" class="changeplayer right"><div class="arrow"></div></div>';
    html += '</div>';

    UI.showSpectator(html);
};

/**
 * Switch to spectating another player after a delay
 * 
 * This is for when players are killed or leave the game
 */
Games.spectatorSwitch = function(id) {
    setTimeout(function() {
        if (id === game.spectatingID) {
            Network.spectateNext();
        }
    }, 2000);
};

/**
 * GAME_PLAYERSALIVE message handler
 * 
 * Displays number of players still alive - this is for BTR
 */
Games.playersAlive = function(numberAlive) {
    let html = '';
    if (numberAlive > 1) {
        html = `<div class="playersalive">${numberAlive} players alive</div>`;
    }
    $('#gamespecific').html(html);
};

/**
 * SERVER_CUSTOM type 1 (BTR) message handler
 */
Games.showBTRWin = function(info) {
    // Only display if no other custom message is currently displayed
    if (!$('#custom-msg').length) {
        let html = '';
        
        // Trophy image, number of kills, and bounty awarded to player
        html += '<div id="custom-msg" class="btrwin">';
        html += '<div class="trophy"></div>';
        html += '<div class="winner">';
        html += '<div class="player"><span class="flag big flag-' + UI.escapeHTML(info.f) + '"></span>' + UI.escapeHTML(info.p) + '</div>';
        html += '</div>';
        html += '<div class="bounty">';
        html += '<span class="stat">' + UI.escapeHTML(info.k) + ' KILL' + (info.k == 1 ? '' : 'S') + '</span>';
        html += '+' + UI.escapeHTML(info.b) + ' BOUNTY';
        html += '</div>';
        html += '</div>';

        // Display message and play sound
        $('body').append(html);
        UI.showPanel('#custom-msg');
        setTimeout(function() {
            UI.hidePanel('#custom-msg', false, true);
        }, 1000 * info.t);
        Sound.gameComplete();
    }
};

/**
 * SERVER_CUSTOM type 2 (CTF) message handler
 */
Games.showCTFWin = function(info) {
    // Only display if no other custom message is currently displayed
    if (!$('#custom-msg').length) {
        let html = '';
        
        // Trophy, winning team, and bounty awarded to player
        html += '<div id="custom-msg" class="ctfwin">';
        html += '<div class="trophy"></div>';
        html += '<div class="winner">' + (info.w == 1 ? '<div class="player blue">BLUE TEAM</div>' : '<div class="player red">RED TEAM</div>') + '</div>';
        html += '<div class="bounty">+' + UI.escapeHTML(info.b) + ' BOUNTY</div></div>';

        // Display message and play sound
        $('body').append(html);
        UI.showPanel('#custom-msg');
        setTimeout(function() {
            UI.hidePanel('#custom-msg', false, true)
        }, 1000 * info.t);
        Sound.gameComplete();
    }
};

Games.showLevelUp = function(level) {
    // Clear any existing custom message
    if ($('#custom-msg').length) {
        $('#custom-msg').remove();
    }

    // Feature unlocked text
    let featureUnlockHtml = '';
    let divclass = ' lvlsmaller';
    if (unlockedFeature[level + ''] != null) {
        divclass = '';
        featureUnlockHtml = '<div class="unlocked">FEATURE UNLOCKED<br><div class="unlockedtext">' + unlockedFeature[level + ''] + "</div></div>";
    }

    // New level reached text, and level number in badge
    let html = '<div id="custom-msg" class="levelup' + divclass + '">' +
               '<div class="leveltext">NEW LEVEL REACHED</div>' + 
               '<div class="levelbadge"></div>' +
               '<div class="levelnum">' + level + "</div>" + featureUnlockHtml + "</div>";

    // Display message and play sound
    $('body').append(html);
    UI.showPanel('#custom-msg');
    setTimeout(function() { 
        UI.hidePanel('#custom-msg', false, true, true) 
    }, 2000);
    Sound.levelUp();
};

/**
 * Update firewall sprites and minimap mask
 */
Games.popFirewall = function(firewallPosition, firewallRadius) {
    if (firewallRadius <= 0) {
        firewallRadius = 0;
    }

    // Create Graphics object for firewall minimap mask if it doesn't already exist
    if (!minimapFirewallVisible) {
        minimapFirewallVisible = true;
        minimapFirewallMask = new PIXI.Graphics;
        game.graphics.gui.minimap.mask = minimapFirewallMask;
    }

    // Draw firewall mask on minimap
    minimapFirewallMask.clear();
    minimapFirewallMask.beginFill(0xFFFFFF);
    minimapFirewallMask.drawCircle(
        game.screenX - config.minimapPaddingX - config.minimapSize * (16384 - firewallPosition.x) / 32768, 
        game.screenY - config.minimapPaddingY - config.minimapSize / 2 * (8192 - firewallPosition.y) / 16384, 
        2 * firewallRadius / (256 / config.minimapSize * 256));
    minimapFirewallMask.endFill();

    // Calculate extent of firewall sprite grid
    let horizonalSpriteCount = Math.ceil((game.halfScreenX + 64) / game.scale / 64);
    let verticalSpriteCount =  Math.ceil((game.halfScreenY + 64) / game.scale / 64);
    let activeSprites = {};

    // Coordinates of the visible border
    let camera = Graphics.getCamera();
    let upperLeft =  new Vector(camera.x - game.halfScreenX / game.scale - 64, camera.y - game.halfScreenY / game.scale - 64);
    let upperRight = new Vector(camera.x + game.halfScreenX / game.scale + 64, camera.y - game.halfScreenY / game.scale - 64);
    let lowerLeft =  new Vector(camera.x - game.halfScreenX / game.scale - 64, camera.y + game.halfScreenY / game.scale + 64);
    let lowerRight = new Vector(camera.x + game.halfScreenX / game.scale + 64, camera.y + game.halfScreenY / game.scale + 64);

    // Check if any part of the firewall is currently visible
    if (Tools.distance(firewallPosition.x, firewallPosition.y, upperLeft.x, upperLeft.y) > firewallRadius || 
        Tools.distance(firewallPosition.x, firewallPosition.y, upperRight.x, upperRight.y) > firewallRadius ||
        Tools.distance(firewallPosition.x, firewallPosition.y, lowerLeft.x, lowerLeft.y) > firewallRadius || 
        Tools.distance(firewallPosition.x, firewallPosition.y, lowerRight.x, lowerRight.y) > firewallRadius) {
        
        // Iterate over firewall sprite grid
        for (let x = -horizonalSpriteCount; x <= horizonalSpriteCount; x++) {
            for (let y = -verticalSpriteCount; y <= verticalSpriteCount; y++) {
                let posX = 64 * (Math.floor(camera.x / 64) + 0.5) + 64 * x;
                let posY = 64 * (Math.floor(camera.y / 64) + 0.5) + 64 * y;
                let distance = Tools.distance(posX, posY, firewallPosition.x, firewallPosition.y)

                // If position is outside of firewall radius then we display the hot smoke
                if (distance >= firewallRadius) {
                    let name = `${posX}_${posY}`;
                    activeSprites[name] = true;

                    // Create firewall sprite for this position if it doesn't already exist
                    if (firewallSprites[name] == null)
                    {
                        let sprite = Textures.sprite(`hotsmoke_${Tools.randInt(1, 4)}`);

                        sprite.scale.set(Tools.rand(1.5, 2.5));
                        sprite.anchor.set(0.5, 0.5);
                        sprite.position.set(posX, posY);
                        let maxOpacity = 1;
                        if (Tools.rand(0, 1) > 0.5) {
                            sprite.blendMode = PIXI.BLEND_MODES.ADD;
                            maxOpacity = 0.5;
                        }

                        game.graphics.layers.powerups.addChild(sprite);

                        firewallSprites[name] = {
                            sprite: sprite,
                            rotation: Tools.rand(0, 100),
                            rotationSpeed: Tools.rand(-0.0025, 0.0025),
                            opacity: 0,
                            maxOpacity: maxOpacity,
                            opacitySpeed: distance - firewallRadius >= 64 ? 0.02 : 0.0035,
                            color: Tools.rand(0, 1),
                            colorDir: Tools.rand(0, 1) < 0.5 ? -1 : 1
                        }
                    }
                }
            }
        }
    }

    for (let name in firewallSprites) {
        if (activeSprites[name]) {
            // Animate sprite by varying its display properties
            firewallSprites[name].rotation += firewallSprites[name].rotationSpeed * game.timeFactor;
            firewallSprites[name].opacity += firewallSprites[name].opacitySpeed * game.timeFactor;
            if (firewallSprites[name].opacity > firewallSprites[name].maxOpacity) {
                firewallSprites[name].opacity = firewallSprites[name].maxOpacity
            }
            firewallSprites[name].color += 0.005 * firewallSprites[name].colorDir * game.timeFactor;
            if (firewallSprites[name].color < 0) {
                firewallSprites[name].colorDir = 1;
            }
            if (firewallSprites[name].color > 1) {
                firewallSprites[name].colorDir = -1;
            }

            // Apply properties to sprite
            firewallSprites[name].sprite.rotation = firewallSprites[name].rotation;
            firewallSprites[name].sprite.alpha = firewallSprites[name].opacity;
            firewallSprites[name].sprite.tint = Tools.colorLerp(0xFAA806, 0xFA4F06, firewallSprites[name].color);
        }
        else {
            // Remove this firewall sprite
            game.graphics.layers.powerups.removeChild(firewallSprites[name].sprite);
            firewallSprites[name].sprite.destroy();
            delete firewallSprites[name];
        }
    }
};

/**
 * Remove all BTR firewall sprites and minimap mask
 */
var removeFirewall = function() {
    if (minimapFirewallVisible) {
        for (let name in firewallSprites) {
            game.graphics.layers.powerups.removeChild(firewallSprites[name].sprite),
            firewallSprites[name].sprite.destroy();
        }

        firewallSprites = {};

        game.graphics.gui.minimap.mask = null;

        if (minimapFirewallMask) {
            minimapFirewallMask.destroy();
            minimapFirewallMask = null;
        }

        minimapFirewallVisible = false;
    }
};

/**
 * GAME_FIREWALL message handler
 */
Games.handleFirewall = function(msg) {
    if (msg.status == 0) {
        removeFirewall();
    }
    else {
        firewall.radius = msg.radius;
        firewall.pos.x = msg.posX;
        firewall.pos.y = msg.posY;
        firewall.speed = msg.speed;
        Games.popFirewall(firewall.pos, firewall.radius);
    }
};

function drawControlpoint(cp, end_progress) {
    const line = cp.line;
    const width = cp.width;
    const square8th = width/2;
    const total8th = end_progress/8;
    const total4th = end_progress/4;
    const factor = square8th/total8th;
    let p = Math.abs(cp.progress);
    line.clear();
    if (p > 0) {
        line.lineStyle(10, cp.progress > 0 ? red_color : blue_color, 1);
        line.moveTo(square8th, 0);
        if (p >= 0)
        line.lineTo(square8th+Math.min(square8th, p*factor), 0);
        p -= total8th;
        if (p >= 0)
        line.lineTo(width, Math.min(width, p*factor));
        p -= total4th;
        if (p >= 0)
        line.lineTo(width-Math.min(width, p*factor), width);
        p -= total4th;
        if (p >= 0)
        line.lineTo(0, width-Math.min(width, p*factor));
        p -= total4th;
        if (p >= 0)
        line.lineTo(Math.min(square8th, p*factor), 0);  
    }

    if (cp.team === 0)
        cp.label.tint = 0xffffff;
    else if (cp.team === 1)
        cp.label.tint = blue_color;
    else if (cp.team === 2)
        cp.label.tint = red_color;

    Graphics.renderer.render(cp.obj, cp.texture, true);
}

/**
 * Frame update handler
 */
Games.update = function(isResize) {
    switch (game.gameType) {
        case GameType.CTF:
            if (ctf.flagBlue) {
                updateCtfFlag(ctf.flagBlue, isResize);
            }
            if (ctf.flagRed) {
                updateCtfFlag(ctf.flagRed, isResize);
            }
            break;
        case GameType.BTR:
            if (minimapFirewallVisible) {
                firewall.radius += firewall.speed / 60 * game.timeFactor;
                Games.popFirewall(firewall.pos, firewall.radius);
            }
            break;
            case GameType.FFA:
                if (ctf.flagBlue) 
                    updateCtfFlag(ctf.flagBlue, isResize);
                if (ctf.flagRed)
                    updateCtfFlag(ctf.flagRed, isResize);
                break;
            case GameType.CONQUEST:
                if (config.manifest.mapId == game.server.config.mapId) {
                    const END_SCORE = config.extra?.conquest_end_score || 60*60*10;
                    const END_PROGRESS = config.extra?.conquest_end_progress || 600;
                
                    let timeFrac = game.timeFactor;
    
                    if (this.reducedFactor !== false) {
                        timeFrac -= this.reducedFactor;
                        this.reducedFactor = false;
                    }
                    
                    if (timeFrac > 0) {
                        const roundedFrames = timeFrac > .51 ? Math.round(timeFrac) : 1;
                        const perLoopEffect = timeFrac / roundedFrames;
                        for (let cp of conquest.zones) {
                            for (let i = 0; i < roundedFrames; i++) {
                                if (cp.team === 1)
                                    conquest.score_blue += perLoopEffect * 1;
                                else if (cp.team === 2)
                                    conquest.score_red += perLoopEffect * 1;
                                if (conquest.score_blue > END_SCORE)
                                    conquest.score_blue = END_SCORE;
                                if (conquest.score_red > END_SCORE)
                                    conquest.score_red = END_SCORE;
                                updateProgressbar(conquest.blue_bar, conquest.score_blue/END_SCORE);
                                updateProgressbar(conquest.red_bar, conquest.score_red/END_SCORE);
    
                                cp.progress += perLoopEffect * 1 * Math.sign(cp.netplayers);
                                if (cp.progress > END_PROGRESS)
                                    cp.progress = END_PROGRESS;
                                if (cp.progress < -END_PROGRESS)
                                    cp.progress = -END_PROGRESS;
                                drawControlpoint(cp, END_PROGRESS);
                            }  
                        }              
                    }
                }
                if(isResize && conquest.zones?.length) {
                    const space = conquest.zones.length * 25;
                    let ui_x = Math.round(game.halfScreenX - space/2);
                    for (let i=0; i<conquest.zones.length; i++) {
                        const cp = conquest.zones[i];
                        cp.ui.x = ui_x;
                        ui_x += 30;
    
                        Graphics.minimapMob(cp.minimap, cp.big.x, cp.big.y);
                    }
                    const bar_width = 200, bar_margin = 20;
                    const x_offset = bar_width/2 + Math.abs(space/2) + bar_margin
                    conquest.red_bar.container.x = Math.round(game.halfScreenX + x_offset);
                    conquest.blue_bar.container.x = Math.round(game.halfScreenX - x_offset);            
                }
                break;
    }
};

const team_colors = ["#e6194b", "#3cb44b", "#ffe119", "#f58231", "#911eb4", "#46f0f0", "#f032e6",  "#bcf60c", "#008080"];
let assigned_team_colors = {};
Games.assign_team_color = function(team) {
    if (assigned_team_colors[team]) {
        return assigned_team_colors[team];
    } else {
        let available = team_colors.filter(x => !Object.values(assigned_team_colors).includes(x));
        if (!available.length)
            available = team_colors;
        const color = available[Math.floor(Math.random()*available.length)];
        assigned_team_colors[team] = color;
        return color;
    }
};

Games.unassign_team_color = function(team) {
    assigned_team_colors[team] = null;
};

Games.updateTdmScore = function(blue_score, red_score) {
    if (!game.server.config.tdmMode) return;
    $('#blueflag-name').html(`<span class="rounds">${blue_score}</span>`);
    $('#redflag-name').html(`<span class="rounds">${red_score}</span>`);
};